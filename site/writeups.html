<!doctype html>
<html lang="en">
<head>
  <meta charset="utf-8">
  <meta name="viewport" content="width=device-width, initial-scale=1">
  <meta name="description" content="Flagaholic - Hong Kong based CTF team focusing on Web, Pwn, Crypto, Forensics, and Misc.">
  
  <link rel="apple-touch-icon" sizes="180x180" href="./assets/favicon/apple-touch-icon.png">
  <link rel="icon" type="image/png" sizes="32x32" href="./assets/favicon/favicon-32x32.png">
  <link rel="icon" type="image/png" sizes="16x16" href="./assets/favicon/favicon-16x16.png">
  <link rel="manifest" href="./assets/favicon/site.webmanifest">
  <meta name="msapplication-TileColor" content="#0f1720">
  <meta name="theme-color" content="#0f1720">
  
  <link rel="preconnect" href="https://fonts.googleapis.com">
  <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
  <link href="https://fonts.googleapis.com/css2?family=Inter:wght@400;500;600&display=swap" rel="stylesheet">
  
  <link rel="stylesheet" href="./css/site.css">
  <link rel="stylesheet" href="./css/writeup_tree.css">
  
  <title>Writeups â€” Flagaholic</title>
</head>

<body>
  <div class="wrap">
    <header>
      <div class="brand">
        <img class="logo" src="./assets/teamlogo/teampfp.png" alt="Flagaholic" width="40" height="40" loading="eager" decoding="async">
        <strong>Flagaholic</strong>
      </div>
      <nav>
        <a href="./index.html">Home</a>
        <a href="./members.html">Members</a>
        <a href="./achievements.html">Achievements</a>
        <a href="./writeups.html">Writeups</a>
        <a href="./contact.html">Contact</a>
      </nav>
    </header>

		<script>
			window.mobileCheck = function() {
				let check = false;
				(function(a){if(/(android|bb\d+|meego).+mobile|avantgo|bada\/|blackberry|blazer|compal|elaine|fennec|hiptop|iemobile|ip(hone|od)|iris|kindle|lge |maemo|midp|mmp|mobile.+firefox|netfront|opera m(ob|in)i|palm( os)?|phone|p(ixi|re)\/|plucker|pocket|psp|series(4|6)0|symbian|treo|up\.(browser|link)|vodafone|wap|windows ce|xda|xiino/i.test(a)||/1207|6310|6590|3gso|4thp|50[1-6]i|770s|802s|a wa|abac|ac(er|oo|s\-)|ai(ko|rn)|al(av|ca|co)|amoi|an(ex|ny|yw)|aptu|ar(ch|go)|as(te|us)|attw|au(di|\-m|r |s )|avan|be(ck|ll|nq)|bi(lb|rd)|bl(ac|az)|br(e|v)w|bumb|bw\-(n|u)|c55\/|capi|ccwa|cdm\-|cell|chtm|cldc|cmd\-|co(mp|nd)|craw|da(it|ll|ng)|dbte|dc\-s|devi|dica|dmob|do(c|p)o|ds(12|\-d)|el(49|ai)|em(l2|ul)|er(ic|k0)|esl8|ez([4-7]0|os|wa|ze)|fetc|fly(\-|_)|g1 u|g560|gene|gf\-5|g\-mo|go(\.w|od)|gr(ad|un)|haie|hcit|hd\-(m|p|t)|hei\-|hi(pt|ta)|hp( i|ip)|hs\-c|ht(c(\-| |_|a|g|p|s|t)|tp)|hu(aw|tc)|i\-(20|go|ma)|i230|iac( |\-|\/)|ibro|idea|ig01|ikom|im1k|inno|ipaq|iris|ja(t|v)a|jbro|jemu|jigs|kddi|keji|kgt( |\/)|klon|kpt |kwc\-|kyo(c|k)|le(no|xi)|lg( g|\/(k|l|u)|50|54|\-[a-w])|libw|lynx|m1\-w|m3ga|m50\/|ma(te|ui|xo)|mc(01|21|ca)|m\-cr|me(rc|ri)|mi(o8|oa|ts)|mmef|mo(01|02|bi|de|do|t(\-| |o|v)|zz)|mt(50|p1|v )|mwbp|mywa|n10[0-2]|n20[2-3]|n30(0|2)|n50(0|2|5)|n7(0(0|1)|10)|ne((c|m)\-|on|tf|wf|wg|wt)|nok(6|i)|nzph|o2im|op(ti|wv)|oran|owg1|p800|pan(a|d|t)|pdxg|pg(13|\-([1-8]|c))|phil|pire|pl(ay|uc)|pn\-2|po(ck|rt|se)|prox|psio|pt\-g|qa\-a|qc(07|12|21|32|60|\-[2-7]|i\-)|qtek|r380|r600|raks|rim9|ro(ve|zo)|s55\/|sa(ge|ma|mm|ms|ny|va)|sc(01|h\-|oo|p\-)|sdk\/|se(c(\-|0|1)|47|mc|nd|ri)|sgh\-|shar|sie(\-|m)|sk\-0|sl(45|id)|sm(al|ar|b3|it|t5)|so(ft|ny)|sp(01|h\-|v\-|v )|sy(01|mb)|t2(18|50)|t6(00|10|18)|ta(gt|lk)|tcl\-|tdg\-|tel(i|m)|tim\-|t\-mo|to(pl|sh)|ts(70|m\-|m3|m5)|tx\-9|up(\.b|g1|si)|utst|v400|v750|veri|vi(rg|te)|vk(40|5[0-3]|\-v)|vm40|voda|vulc|vx(52|53|60|61|70|80|81|83|85|98)|w3c(\-| )|webc|whit|wi(g |nc|nw)|wmlb|wonu|x700|yas\-|your|zeto|zte\-/i.test(a.substr(0,4))) check = true;})(navigator.userAgent||navigator.vendor||window.opera);
				return check;
			};

			async function loadDirectory() {
				const apiBase = 'https://api.github.com/repos/Flagaholic/flagaholic.github.io/contents/site/writeups/';
				const ul = document.getElementById('writeups-list');

				const loadingNotice = document.createElement('li');
				loadingNotice.textContent = 'Fetching newer writeups...';
				loadingNotice.classList.add('no-tree', 'loading');
				ul.appendChild(loadingNotice);

				const manualLinks = new Map();
				Array.from(ul.querySelectorAll('a')).forEach(link => {
					try {
						manualLinks.set(new URL(link.getAttribute('href'), window.location.href).href, link.closest('li'));
						const yearLi = link.closest('li');
						if (yearLi) yearLi.classList.add('manual');
					} catch (e) { }
				});

				Array.from(ul.querySelectorAll('li[data-auto="1"]')).forEach(n => n.remove());

				async function fetchFile(path) {
					const ReadPath = `https://raw.githubusercontent.com/Flagaholic/flagaholic.github.io/main/${path}`;
					try {
						const res = await fetch(ReadPath);
						if (!res.ok) return null;
						const text = await res.text();
						return text;
					} catch {
						return null;
					}
				}

				function getOrCreateYearNode(yearName) {
					// try to find an existing manual year li by exact text
					let existing = Array.from(ul.children).find(li =>
						li.firstChild?.nodeType === Node.TEXT_NODE &&
						li.firstChild.textContent.trim() === yearName
					);
					if (existing) {
						// reuse, do NOT mark manual as data-auto
						let yearUl = existing.querySelector('ul') || document.createElement('ul');
						if (!existing.contains(yearUl)) existing.appendChild(yearUl);
						return { yearLi: existing, yearUl };
					}
					// Not found -> create auto node
					const yearLi = document.createElement('li');
					yearLi.setAttribute('data-auto', '1');
					yearLi.textContent = yearName;
					const yearUl = document.createElement('ul');
					yearLi.appendChild(yearUl);
					ul.appendChild(yearLi);
					return { yearLi, yearUl };
				}

				function getOrCreateCompNode(yearUl, compNameRaw) {
					fetchFile('site/writeups/' + encodeURIComponent(yearUl.parentElement.textContent.trim()) + '/' + encodeURIComponent(compNameRaw) + '/README.md').then(text => {
					    if (text) {
								// if special title
								FirstLine = text.split('\n')[0].trim();
								if (FirstLine.startsWith('# ')) {
									const displayName = FirstLine.substring(2).trim();
								} else {
									const displayName = compNameRaw.replace(/[-_]/g, ' ');
								}
								const compLink = text.match(/https?:\/\/[^\s]+.[^\s]{2,4}\/[^\s]*/);
								if (compLink) {
									const compLinkA = document.createElement('a');
									compLinkA.href = compLink[0];
									compLinkA.textContent = displayName;
								}
						}
					});
					// try to find existing comp li inside yearUl (manual or auto)
					let existing = Array.from(yearUl.children).find(li =>
						(li.firstChild?.nodeType === Node.TEXT_NODE ||
						 li.firstChild?.nodeType === Node.ELEMENT_NODE) &&
						 li.firstChild.textContent.trim() === displayName
					);
					if (existing) {
						let compUl = existing.querySelector('ul') || document.createElement('ul');
						if (compLink && !(existing.nodeType === Node.ELEMENT_NODE || existing.firstChild?.href === compLink?.href)) existing.firstChild = compLink;
						if (!existing.contains(compUl)) existing.appendChild(compUl);
						return { compLi: existing, compUl };
					}
					// create auto node
					const compLi = document.createElement('li');
					compLi.setAttribute('data-auto', '1');
					if (compLink) {
						compLi.appendChild(compLink);
					} else {
						compLi.textContent = displayName;
					}
					const compUl = document.createElement('ul');
					compLi.appendChild(compUl);
					yearUl.appendChild(compLi);
					return { compLi, compUl };
				}

				let writeupCount = 0;
				
				function updateStats() {
					const countSpan = document.getElementById('writeup-count');
					countSpan.textContent = `${writeupCount} writeups found`;
				}

				function appendWuIfNotExists(compUl, href, display, files) {
					const resolved = new URL(href, window.location.href).href;
					if (manualLinks.has(resolved)) return false;
					if (Array.from(compUl.querySelectorAll('a')).some(a => {
						try { return new URL(a.getAttribute('href'), window.location.href).href === resolved; } catch (e) { return false; }
					})) return false;

					if (!files.some(f => f.toLowerCase() === 'readme.md')) return false;

					const wuLi = document.createElement('li');
					wuLi.setAttribute('data-auto', '1');
					const wuLink = document.createElement('a');
					wuLink.href = href;
					wuLink.textContent = (display.lastIndexOf('-') !== -1) ? display.substring(0, display.lastIndexOf('-')) + '-' + display.substring(display.lastIndexOf('-') + 1).replace(/[-_]/g, ' ') : display;
					
					if (window.mobileCheck()) {
						let previewTimeout;
						let previewDiv;
						
						// hover preview
						wuLink.addEventListener('mouseenter', async () => {
							previewTimeout = setTimeout(async () => {
								try {
									const res = await fetch(href);
									if (!res.ok) return;

									let html = await res.text();

									const temp = document.createElement('div');
									temp.innerHTML = html;
									const header = temp.querySelector('header');
									if (header) header.remove();
									html = temp.innerHTML;

									previewDiv = document.createElement('div');
									previewDiv.className = 'writeup-preview';

									const maxWidth = Math.min(window.innerWidth * 0.6, 900);
									const maxHeight = Math.min(window.innerHeight * 0.6, 700);

									const iframe = document.createElement('iframe');
									iframe.sandbox = 'allow-same-origin';
									iframe.style.width = `${maxWidth}px`;
									iframe.style.height = `${maxHeight}px`;
									previewDiv.appendChild(iframe);

									document.body.appendChild(previewDiv);

									const doc = iframe.contentDocument || iframe.contentWindow.document;
									doc.open();
									doc.write(html);
									doc.close();

									const rect = wuLink.getBoundingClientRect();
									let x = rect.right + 20;
									let y = rect.top;

									// prevent it from going off screen
									if (x + maxWidth > window.innerWidth) x = rect.left - maxWidth - 20;
									if (y + maxHeight > window.innerHeight) y = window.innerHeight - maxHeight - 20;

									previewDiv.style.position = 'fixed';
									previewDiv.style.left = `${x}px`;
									previewDiv.style.top = `${y}px`;
									previewDiv.style.zIndex = '9999';
									previewDiv.style.opacity = '0';
									previewDiv.style.transition = 'opacity 0.2s ease-in-out';

									requestAnimationFrame(() => {
										previewDiv.style.opacity = '1';
									});
								} catch (err) {
									console.error('Preview failed:', err);
								}
							}, 500);
						});


						wuLink.addEventListener('mouseleave', () => {
							clearTimeout(previewTimeout);
							if (previewDiv) {
								previewDiv.remove();
								previewDiv = null;
							}
						});
					};

					wuLi.appendChild(wuLink);
					compUl.appendChild(wuLi);
					writeupCount++;
					updateStats();
					return true;
				}

				async function fetchTreeInstead(apiBaseUrl) {
					const match = apiBaseUrl.match(/^https:\/\/api\.github\.com\/repos\/([^/]+)\/([^/]+)\/contents\/(.+)$/);
					if (!match) return null;
					const owner = match[1], repo = match[2], basePath = match[3].replace(/\/$/, ''); // dont ask me why I didnt set them at the first place and snap the urls from them and instead use regex (but if u rlly wanna know its so I can use non github api urls to debug without breaking this or sth)
					// main should always be present and this check isnt even necessary but yk its good to have a failsafe when someone messed it up
					const branches = ['main', 'master', 'gh-pages', 'HEAD'];
					for (const branch of branches) {
						try {
							const treeUrl = `https://api.github.com/repos/${owner}/${repo}/git/trees/${branch}?recursive=1`;
							const res = await fetch(treeUrl);
							if (!res.ok) continue;
							const json = await res.json();
							if (!json.tree) continue;
							// build map of directories -> md files
							const treeFiles = json.tree.filter(e => e.type === 'blob' && e.path.startsWith(basePath + '/'));
							return { basePath, files: treeFiles };
						} catch (e) {
							// ignore and try next branch
						}
					}
					return null;
				}

				try {
					const treeResult = await fetchTreeInstead(apiBase);

					const yearsSeen = new Set();

					if (treeResult) {
						const groups = new Map(); // year -> comp -> wu -> [filenames]
						const basePath = treeResult.basePath;
						for (const file of treeResult.files) {
							if (!/\.md$/i.test(file.path)) continue;
							// path parts after basePath: year/comp/wu/file.md
							const rel = file.path.substring(basePath.length + 1).split('/');
							if (rel.length < 4) continue; // not in expected repo layout (ie. non wu, very very WIP wu, etc)
							const [year, comp, wu, ...rest] = rel;
							const fname = rest.join('/');
							groups.set(year, groups.get(year) || new Map());
							const compMap = groups.get(year);
							compMap.set(comp, compMap.get(comp) || new Map());
							const wuMap = compMap.get(comp);
							wuMap.set(wu, (wuMap.get(wu) || []).concat(fname));
						}

						// build DOM from groups
						for (const [year, compMap] of [...groups.entries()].sort((a, b) => b[0].localeCompare(a[0]))) {
							yearsSeen.add(year);
							const { yearLi, yearUl } = getOrCreateYearNode(year);
							for (const [comp, wuMap] of [...compMap.entries()].sort((a, b) => a[0].localeCompare(b[0]))) {
								const { compLi, compUl } = getOrCreateCompNode(yearUl, comp);
								for (const [wu, files] of [...wuMap.entries()].sort((a, b) => a[0].localeCompare(b[0]))) {
									const href = `../${basePath}/${encodeURIComponent(year)}/${encodeURIComponent(comp)}/${encodeURIComponent(wu)}/`;
									appendWuIfNotExists(compUl, href, wu, files);
								}
							}
						}
					} else {
						// fallback if can't fetch everything at once (this would take lots of github api fetches and its way more likely for the user to get rate-limited)
						const dirRes = await fetch(apiBase);
						if (!dirRes.ok) {
							// sth bad happened, usually the user got rate limited
							if (!manualLinks.size) {
								if (dirRes.status === 403) {
									ul.insertAdjacentHTML('beforeend', '<li>Unable to fetch writeups due to github API rate limiting, please try again later.</li>');
								} else {
									ul.insertAdjacentHTML('beforeend', '<li>Unable to fetch writeups, please try again later. If this issue persists, scream at us in discord and we will fix it asap</li>');
								}
							} else {
								if (dirRes.status === 403) {
									ul.insertAdjacentHTML('beforeend', '<li>Unable to fetch newer writeups due to github API rate limiting. Please try again later, and view the statically loaded writeups instead.</li>');
								} else {
									ul.insertAdjacentHTML('beforeend', '<li>Unable to fetch newer writeups, please try again later. If this issue persists, scream at us in discord and we will fix it asap</li>');
								}
							}
							return;
						}
						const years = await dirRes.json();
						years.sort((a, b) => b.name.localeCompare(a.name));

						for (const year of years) {
							if (year.type !== 'dir') continue;
							yearsSeen.add(year.name);
							const { yearLi, yearUl } = getOrCreateYearNode(year.name);

							const compsRes = await fetch(`${apiBase}${year.name}`);
							if (!compsRes.ok) continue;
							const comps = await compsRes.json();
							comps.sort((a, b) => a.name.localeCompare(b.name));

							for (const comp of comps) {
								if (comp.type !== 'dir') continue;
								const { compLi, compUl } = getOrCreateCompNode(yearUl, comp.name);

								const wusRes = await fetch(`${apiBase}${year.name}/${comp.name}`);
								if (!wusRes.ok) continue;
								const wus = await wusRes.json();
								wus.sort((a, b) => a.name.localeCompare(b.name));

								for (const wu of wus) {
									if (wu.type !== 'dir') continue;
									const wuPath = `./${encodeURIComponent(year.name)}/${encodeURIComponent(comp.name)}/${encodeURIComponent(wu.name)}/`;
									appendWuIfNotExists(compUl, `./writeups/${wuPath}`, wu.name);
								}
							}
						}
					}

					Array.from(ul.querySelectorAll('li[data-auto="1"]')).forEach(li => {
						if (li.parentElement === ul) {
							const yearText = li.firstChild?.nodeType === Node.TEXT_NODE ? li.firstChild.textContent.trim() : null;
							if (yearText && !yearsSeen.has(yearText)) li.remove();
						}
					});

				} catch (err) {
					if (!manualLinks.size) {
						ul.insertAdjacentHTML('beforeend', '<li>Error loading writeups. If you didn\'t change anything please scream at us in discord with the console logged error :pray:</li>');
					}
					console.error(err);
				} finally {
					if (loadingNotice && loadingNotice.parentElement) loadingNotice.parentElement.removeChild(loadingNotice);
				}
			}

			document.addEventListener('DOMContentLoaded', loadDirectory);
		</script>

		<main class="main">
			<div class="card">
				<header class="writeups-header">
					<h1>Writeups</h1>
					<div class="writeups-stats">
						<span id="writeup-count">Loading...</span>
						<span id="filter-info"></span>
					</div>
				</header>
				<ul id="writeups-list">
					<!-- populated dynamically unless entries manually added here (idk cuz your wu is special or the auto fetch script is crying for help and can't get your writeup or sth) -->
					<!-- <li>[COATING OR ETC]<ul> -->
					<!-- <li><a href="./writeups/YEAR/COMP/CHAL/">[DISPLAY NAME]</a></li> -->
					<!-- </ul></li> -->
					<li>2025<ul>
						<li><a href="https://ctftime.org/event/2920">V1t CTF 2025</a><ul>
							<li><a href="https://hackmd.io/@xzhiyouu/BJDXuxHJbl#Misc-Dont-Bother">misc - Dont Bother</a></li>
							<li><a href="https://hackmd.io/@xzhiyouu/BJDXuxHJbl#Misc-MOOOO">misc - MOOOO</a></li>
							<li><a href="https://hackmd.io/@xzhiyouu/BJDXuxHJbl#Forensics-Tryna-crack">forensics - Tryna crack?</a></li>
						</ul></li>
					</ul></li>
				</ul>
			</div>
		</main>
	</div>
</body>

</html>