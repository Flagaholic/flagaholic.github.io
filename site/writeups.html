<!doctype html>
<html lang="en">
<head>
  <meta charset="utf-8">
  <meta name="viewport" content="width=device-width, initial-scale=1">
  <meta name="description" content="Flagaholic - Hong Kong based CTF team focusing on Web, Pwn, Crypto, Forensics, and Misc.">
  
  <link rel="apple-touch-icon" sizes="180x180" href="./assets/favicon/apple-touch-icon.png">
  <link rel="icon" type="image/png" sizes="32x32" href="./assets/favicon/favicon-32x32.png">
  <link rel="icon" type="image/png" sizes="16x16" href="./assets/favicon/favicon-16x16.png">
  <link rel="manifest" href="./assets/favicon/site.webmanifest">
  <meta name="msapplication-TileColor" content="#0f1720">
  <meta name="theme-color" content="#0f1720">
  
  <link rel="preconnect" href="https://fonts.googleapis.com">
  <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
  <link href="https://fonts.googleapis.com/css2?family=Inter:wght@400;500;600&display=swap" rel="stylesheet">
  
  <link rel="stylesheet" href="./css/site.css">
  <link rel="stylesheet" href="./css/writeup_tree.css">
  
  <title>Writeups â€” Flagaholic</title>
</head>

<body>
  <div class="wrap">
    <header>
      <div class="brand">
        <img class="logo" src="./assets/teamlogo/teampfp.png" alt="Flagaholic" width="40" height="40" loading="eager" decoding="async">
        <strong>Flagaholic</strong>
      </div>
      <nav>
        <a href="./index.html">Home</a>
        <a href="./members.html">Members</a>
        <a href="./achievements.html">Achievements</a>
        <a href="./writeups.html">Writeups</a>
        <a href="./contact.html">Contact</a>
      </nav>
    </header>

		<script>
			async function loadDirectory() {
				const apiBase = 'https://api.github.com/repos/Flagaholic/flagaholic.github.io/contents/site/writeups/';
				const ul = document.getElementById('writeups-list');

				const loadingNotice = document.createElement('li');
				loadingNotice.textContent = 'Fetching newer writeups...';
				loadingNotice.classList.add('no-tree', 'loading');
				ul.appendChild(loadingNotice);

				const manualLinks = new Map();
				Array.from(ul.querySelectorAll('a')).forEach(link => {
					try {
						manualLinks.set(new URL(link.getAttribute('href'), window.location.href).href, link.closest('li'));
						const yearLi = link.closest('li');
						if (yearLi) yearLi.classList.add('manual');
					} catch (e) { }
				});

				Array.from(ul.querySelectorAll('li[data-auto="1"]')).forEach(n => n.remove());

				function getOrCreateYearNode(yearName) {
					// try to find an existing manual year li by exact text
					let existing = Array.from(ul.children).find(li =>
						li.firstChild?.nodeType === Node.TEXT_NODE &&
						li.firstChild.textContent.trim() === yearName
					);
					if (existing) {
						// reuse, do NOT mark manual as data-auto
						let yearUl = existing.querySelector('ul') || document.createElement('ul');
						if (!existing.contains(yearUl)) existing.appendChild(yearUl);
						return { yearLi: existing, yearUl };
					}
					// Not found -> create auto node
					const yearLi = document.createElement('li');
					yearLi.setAttribute('data-auto', '1');
					yearLi.textContent = yearName;
					const yearUl = document.createElement('ul');
					yearLi.appendChild(yearUl);
					ul.appendChild(yearLi);
					return { yearLi, yearUl };
				}

				function getOrCreateCompNode(yearUl, compNameRaw) {
					const displayName = compNameRaw.replace(/[-_]/g, ' ');
					// try to find existing comp li inside yearUl (manual or auto)
					let existing = Array.from(yearUl.children).find(li =>
						li.firstChild?.nodeType === Node.TEXT_NODE &&
						li.firstChild.textContent.trim() === displayName
					);
					if (existing) {
						let compUl = existing.querySelector('ul') || document.createElement('ul');
						if (!existing.contains(compUl)) existing.appendChild(compUl);
						return { compLi: existing, compUl };
					}
					// create auto node
					const compLi = document.createElement('li');
					compLi.setAttribute('data-auto', '1');
					compLi.textContent = displayName;
					const compUl = document.createElement('ul');
					compLi.appendChild(compUl);
					yearUl.appendChild(compLi);
					return { compLi, compUl };
				}

				let writeupCount = 0;
				
				function updateStats() {
					const countSpan = document.getElementById('writeup-count');
					countSpan.textContent = `${writeupCount} writeups found`;
				}

				function appendWuIfNotExists(compUl, href, display, files) {
					const resolved = new URL(href, window.location.href).href;
					if (manualLinks.has(resolved)) return false;
					if (Array.from(compUl.querySelectorAll('a')).some(a => {
						try { return new URL(a.getAttribute('href'), window.location.href).href === resolved; } catch (e) { return false; }
					})) return false;

					if (!files.some(f => f.toLowerCase() === 'readme.md')) return false;

					const wuLi = document.createElement('li');
					wuLi.setAttribute('data-auto', '1');
					const wuLink = document.createElement('a');
					wuLink.href = href;
					wuLink.textContent = display.replace(/[-_]/g, ' ');
					
					let previewTimeout;
					let previewDiv;
					
					// hover preview
					wuLink.addEventListener('mouseenter', async () => {
						previewTimeout = setTimeout(async () => {
							try {
								const res = await fetch(href);
								if (!res.ok) return;

								let html = await res.text();

								const temp = document.createElement('div');
								temp.innerHTML = html;
								const header = temp.querySelector('header');
								if (header) header.remove();
								html = temp.innerHTML;

								previewDiv = document.createElement('div');
								previewDiv.className = 'writeup-preview';

								const maxWidth = Math.min(window.innerWidth * 0.6, 900);
								const maxHeight = Math.min(window.innerHeight * 0.6, 700);

								const iframe = document.createElement('iframe');
								iframe.sandbox = 'allow-same-origin';
								iframe.style.width = `${maxWidth}px`;
								iframe.style.height = `${maxHeight}px`;
								previewDiv.appendChild(iframe);

								document.body.appendChild(previewDiv);

								const doc = iframe.contentDocument || iframe.contentWindow.document;
								doc.open();
								doc.write(html);
								doc.close();

								const rect = wuLink.getBoundingClientRect();
								let x = rect.right + 20;
								let y = rect.top;

								// prevent it from going off screen
								if (x + maxWidth > window.innerWidth) x = rect.left - maxWidth - 20;
								if (y + maxHeight > window.innerHeight) y = window.innerHeight - maxHeight - 20;

								previewDiv.style.position = 'fixed';
								previewDiv.style.left = `${x}px`;
								previewDiv.style.top = `${y}px`;
								previewDiv.style.zIndex = '9999';
								previewDiv.style.opacity = '0';
								previewDiv.style.transition = 'opacity 0.2s ease-in-out';

								requestAnimationFrame(() => {
									previewDiv.style.opacity = '1';
								});
							} catch (err) {
								console.error('Preview failed:', err);
							}
						}, 500);
					});


					wuLink.addEventListener('mouseleave', () => {
						clearTimeout(previewTimeout);
						if (previewDiv) {
							previewDiv.remove();
							previewDiv = null;
						}
					});

					wuLi.appendChild(wuLink);
					compUl.appendChild(wuLi);
					writeupCount++;
					updateStats();
					return true;
				}

				async function fetchTreeInstead(apiBaseUrl) {
					const match = apiBaseUrl.match(/^https:\/\/api\.github\.com\/repos\/([^/]+)\/([^/]+)\/contents\/(.+)$/);
					if (!match) return null;
					const owner = match[1], repo = match[2], basePath = match[3].replace(/\/$/, ''); // dont ask me why I didnt set them at the first place and snap the urls from them and instead use regex (but if u rlly wanna know its so I can use non github api urls to debug without breaking this or sth)
					// main should always be present and this check isnt even necessary but yk its good to have a failsafe when someone messed it up
					const branches = ['main', 'master', 'gh-pages', 'HEAD'];
					for (const branch of branches) {
						try {
							const treeUrl = `https://api.github.com/repos/${owner}/${repo}/git/trees/${branch}?recursive=1`;
							const res = await fetch(treeUrl);
							if (!res.ok) continue;
							const json = await res.json();
							if (!json.tree) continue;
							// build map of directories -> md files
							const treeFiles = json.tree.filter(e => e.type === 'blob' && e.path.startsWith(basePath + '/'));
							return { basePath, files: treeFiles };
						} catch (e) {
							// ignore and try next branch
						}
					}
					return null;
				}

				try {
					const treeResult = await fetchTreeInstead(apiBase);

					const yearsSeen = new Set();

					if (treeResult) {
						const groups = new Map(); // year -> comp -> wu -> [filenames]
						const basePath = treeResult.basePath;
						for (const file of treeResult.files) {
							if (!/\.md$/i.test(file.path)) continue;
							// path parts after basePath: year/comp/wu/file.md
							const rel = file.path.substring(basePath.length + 1).split('/');
							if (rel.length < 4) continue; // not in expected repo layout (ie. non wu, very very WIP wu, etc)
							const [year, comp, wu, ...rest] = rel;
							const fname = rest.join('/');
							groups.set(year, groups.get(year) || new Map());
							const compMap = groups.get(year);
							compMap.set(comp, compMap.get(comp) || new Map());
							const wuMap = compMap.get(comp);
							wuMap.set(wu, (wuMap.get(wu) || []).concat(fname));
						}

						// build DOM from groups
						for (const [year, compMap] of [...groups.entries()].sort((a, b) => b[0].localeCompare(a[0]))) {
							yearsSeen.add(year);
							const { yearLi, yearUl } = getOrCreateYearNode(year);
							for (const [comp, wuMap] of [...compMap.entries()].sort((a, b) => a[0].localeCompare(b[0]))) {
								const { compLi, compUl } = getOrCreateCompNode(yearUl, comp);
								for (const [wu, files] of [...wuMap.entries()].sort((a, b) => a[0].localeCompare(b[0]))) {
									const href = `../${basePath}/${encodeURIComponent(year)}/${encodeURIComponent(comp)}/${encodeURIComponent(wu)}/`;
									appendWuIfNotExists(compUl, href, wu, files);
								}
							}
						}
					} else {
						// fallback if can't fetch everything at once (this would take lots of github api fetches and its way more likely for the user to get rate-limited)
						const dirRes = await fetch(apiBase);
						if (!dirRes.ok) {
							// sth bad happened, usually the user got rate limited
							if (!manualLinks.size) {
								if (dirRes.status === 403) {
									ul.insertAdjacentHTML('beforeend', '<li>Unable to fetch writeups due to github API rate limiting, please try again later.</li>');
								} else {
									ul.insertAdjacentHTML('beforeend', '<li>Unable to fetch writeups, please try again later. If this issue persists, scream at us in discord and we will fix it asap</li>');
								}
							} else {
								if (dirRes.status === 403) {
									ul.insertAdjacentHTML('beforeend', '<li>Unable to fetch newer writeups due to github API rate limiting. Please try again later, and view the statically loaded writeups instead.</li>');
								} else {
									ul.insertAdjacentHTML('beforeend', '<li>Unable to fetch newer writeups, please try again later. If this issue persists, scream at us in discord and we will fix it asap</li>');
								}
							}
							return;
						}
						const years = await dirRes.json();
						years.sort((a, b) => b.name.localeCompare(a.name));

						for (const year of years) {
							if (year.type !== 'dir') continue;
							yearsSeen.add(year.name);
							const { yearLi, yearUl } = getOrCreateYearNode(year.name);

							const compsRes = await fetch(`${apiBase}${year.name}`);
							if (!compsRes.ok) continue;
							const comps = await compsRes.json();
							comps.sort((a, b) => a.name.localeCompare(b.name));

							for (const comp of comps) {
								if (comp.type !== 'dir') continue;
								const { compLi, compUl } = getOrCreateCompNode(yearUl, comp.name);

								const wusRes = await fetch(`${apiBase}${year.name}/${comp.name}`);
								if (!wusRes.ok) continue;
								const wus = await wusRes.json();
								wus.sort((a, b) => a.name.localeCompare(b.name));

								for (const wu of wus) {
									if (wu.type !== 'dir') continue;
									const wuPath = `./${encodeURIComponent(year.name)}/${encodeURIComponent(comp.name)}/${encodeURIComponent(wu.name)}/`;
									appendWuIfNotExists(compUl, `./writeups/${wuPath}`, wu.name);
								}
							}
						}
					}

					Array.from(ul.querySelectorAll('li[data-auto="1"]')).forEach(li => {
						if (li.parentElement === ul) {
							const yearText = li.firstChild?.nodeType === Node.TEXT_NODE ? li.firstChild.textContent.trim() : null;
							if (yearText && !yearsSeen.has(yearText)) li.remove();
						}
					});

				} catch (err) {
					if (!manualLinks.size) {
						ul.insertAdjacentHTML('beforeend', '<li>Error loading writeups. If you didn\'t change anything please scream at us in discord with the console logged error :pray:</li>');
					}
					console.error(err);
				} finally {
					if (loadingNotice && loadingNotice.parentElement) loadingNotice.parentElement.removeChild(loadingNotice);
				}
			}

			document.addEventListener('DOMContentLoaded', loadDirectory);
		</script>

		<main class="main">
			<div class="card">
				<header class="writeups-header">
					<h1>Writeups</h1>
					<div class="writeups-stats">
						<span id="writeup-count">Loading...</span>
						<span id="filter-info"></span>
					</div>
				</header>
				<ul id="writeups-list">
					<!-- populated dynamically unless entries manually added here (idk cuz your wu is special or the auto fetch script is crying for help and can't get your writeup or sth) -->
					<!-- <li>[COATING OR ETC]<ul> -->
					<!-- <li><a href="./writeups/YEAR/COMP/CHAL/">[DISPLAY NAME]</a></li> -->
					<!-- </ul></li> -->
				</ul>
			</div>
		</main>
	</div>
</body>

</html>