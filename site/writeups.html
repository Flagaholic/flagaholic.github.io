<!doctype html>
<html lang="en">
<head>
	<meta charset="utf-8">
  <meta name="viewport" content="width=device-width, initial-scale=1">
  <meta name="description" content="Flagaholic - Hong Kong based CTF team focusing on Web, Pwn, Crypto, Forensics, and Misc.">
  
  <link rel="apple-touch-icon" sizes="180x180" href="./assets/favicon/apple-touch-icon.png">
  <link rel="icon" type="image/png" sizes="32x32" href="./assets/favicon/favicon-32x32.png">
  <link rel="icon" type="image/png" sizes="16x16" href="./assets/favicon/favicon-16x16.png">
  <link rel="manifest" href="./assets/favicon/site.webmanifest">
  <meta name="msapplication-TileColor" content="#0f1720">
  <meta name="theme-color" content="#0f1720">
  
  <link rel="preconnect" href="https://fonts.googleapis.com">
  <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
  <link href="https://fonts.googleapis.com/css2?family=Inter:wght@400;500;600&display=swap" rel="stylesheet">
  
  <link rel="stylesheet" href="./css/site.css">
  <link rel="stylesheet" href="./css/writeup_tree.css">
  
  <title>Writeups — Flagaholic</title>
</head>

<body>
  <div class="wrap">
    <header>
      <div class="brand">
        <img class="logo" src="./assets/teamlogo/teampfp.png" alt="Flagaholic" width="40" height="40" loading="eager" decoding="async">
        <strong>Flagaholic</strong>
      </div>
      <nav>
        <a href="./index.html">Home</a>
        <a href="./members.html">Members</a>
        <a href="./achievements.html">Achievements</a>
        <a href="./writeups.html">Writeups</a>
        <a href="./contact.html">Contact</a>
      </nav>
    </header>

		<script src="https://cdn.jsdelivr.net/npm/marked/marked.min.js"></script>
		<script>
			async function loadDirectory() {
				const apiBase = 'https://api.github.com/repos/Flagaholic/flagaholic.github.io/contents/site/writeups/';
				const ul = document.getElementById('writeups-list');

				const loadingNotice = document.createElement('li');
				loadingNotice.textContent = 'Fetching newer writeups...';
				loadingNotice.classList.add('no-tree', 'loading');
				ul.appendChild(loadingNotice);

				const manualLinks = new Map();
				Array.from(ul.querySelectorAll('a')).forEach(link => {
					try {
						manualLinks.set(new URL(link.getAttribute('href'), window.location.href).href, link.closest('li'));
						const yearLi = link.closest('li');
						if (yearLi) yearLi.classList.add('manual');
					} catch (e) { }
				});

				Array.from(ul.querySelectorAll('li[data-auto="1"]')).forEach(n => n.remove());

				function getOrCreateYearNode(yearName) {
					// try to find an existing manual year li by exact text
					let existing = Array.from(ul.children).find(li =>
						li.firstChild?.nodeType === Node.TEXT_NODE &&
						li.firstChild.textContent.trim() === yearName
					);
					if (existing) {
						// reuse, do NOT mark manual as data-auto
						let yearUl = existing.querySelector('ul') || document.createElement('ul');
						if (!existing.contains(yearUl)) existing.appendChild(yearUl);
						return { yearLi: existing, yearUl };
					}
					// Not found -> create auto node
					const yearLi = document.createElement('li');
					yearLi.setAttribute('data-auto', '1');
					yearLi.textContent = yearName;
					const yearUl = document.createElement('ul');
					yearLi.appendChild(yearUl);
					ul.appendChild(yearLi);
					return { yearLi, yearUl };
				}

				function getOrCreateCompNode(yearUl, compNameRaw) {
					const displayName = compNameRaw.replace(/[-_]/g, ' ');
					// try to find existing comp li inside yearUl (manual or auto)
					let existing = Array.from(yearUl.children).find(li =>
						li.firstChild?.nodeType === Node.TEXT_NODE &&
						li.firstChild.textContent.trim() === displayName
					);
					if (existing) {
						let compUl = existing.querySelector('ul') || document.createElement('ul');
						if (!existing.contains(compUl)) existing.appendChild(compUl);
						return { compLi: existing, compUl };
					}
					// create auto node
					const compLi = document.createElement('li');
					compLi.setAttribute('data-auto', '1');
					compLi.textContent = displayName;
					const compUl = document.createElement('ul');
					compLi.appendChild(compUl);
					yearUl.appendChild(compLi);
					return { compLi, compUl };
				}

				let writeupCount = 0;
				const readmeDiv = document.getElementById('readme');
				
				function updateStats() {
					const countSpan = document.getElementById('writeup-count');
					countSpan.textContent = `${writeupCount} writeups found`;
				}

				async function previewReadme(url) {
					if (!readmeDiv) return;
					
					readmeDiv.innerHTML = '<div class="readme-header"><h3>Preview</h3><span class="readme-close">×</span></div><p>Loading...</p>';
					readmeDiv.classList.add('loading');
					
					try {
						const res = await fetch(url);
						if (!res.ok) throw new Error('Failed to load README');
						
						const text = await res.text();
						const html = marked.parse(text);
						
						readmeDiv.innerHTML = `
							<div class="readme-header">
								<h3>Preview</h3>
								<span class="readme-close">×</span>
							</div>
							${html}
						`;
						
						// Scroll preview into view
						readmeDiv.scrollIntoView({ behavior: 'smooth', block: 'start' });
					} catch (err) {
						readmeDiv.innerHTML = '<p>Failed to load preview</p>';
						console.error(err);
					} finally {
						readmeDiv.classList.remove('loading');
					}
				}

				function appendWuIfNotExists(compUl, href, display, files) {
					const resolved = new URL(href, window.location.href).href;
					if (manualLinks.has(resolved)) return false;
					if (Array.from(compUl.querySelectorAll('a')).some(a => {
						try { return new URL(a.getAttribute('href'), window.location.href).href === resolved; } catch (e) { return false; }
					})) return false;

					// Check for README.md or other .md files
					const readmeFile = files.find(f => f.toLowerCase() === 'readme.md');
					const mdFile = files.find(f => f.toLowerCase().endsWith('.md'));
					
					if (!readmeFile && !mdFile) return false;

					const wuLi = document.createElement('li');
					wuLi.setAttribute('data-auto', '1');
					const wuLink = document.createElement('a');
					wuLink.href = href + (readmeFile || mdFile);
					wuLink.textContent = display.replace(/[-_]/g, ' ');
					
					// Add preview functionality
					wuLink.addEventListener('click', (e) => {
						e.preventDefault();
						previewReadme(wuLink.href);
					});

					wuLi.appendChild(wuLink);
					compUl.appendChild(wuLi);
					writeupCount++;
					updateStats();
					return true;
				}

				// Add click handler for readme close button
				document.addEventListener('click', (e) => {
					if (e.target.classList.contains('readme-close')) {
						readmeDiv.innerHTML = '';
					}
				});

				// 
				async function fetchTreeInstead(apiBaseUrl) {
					const match = apiBaseUrl.match(/^https:\/\/api\.github\.com\/repos\/([^/]+)\/([^/]+)\/contents\/(.+)$/);
					if (!match) return null;
					const owner = match[1], repo = match[2], basePath = match[3].replace(/\/$/, ''); // dont ask me why I didnt set them at the first place and snap the urls from them and instead use regex (but if u rlly wanna know its so I can use non github api urls to debug without breaking this or sth)
					// main should always be present and this check isnt even necessary but yk its good to have a failsafe when someone messed it up
					const branches = ['main', 'master', 'gh-pages', 'HEAD'];
					for (const branch of branches) {
						try {
							const treeUrl = `https://api.github.com/repos/${owner}/${repo}/git/trees/${branch}?recursive=1`;
							const res = await fetch(treeUrl);
							if (!res.ok) continue;
							const json = await res.json();
							if (!json.tree) continue;
							// build map of directories -> md files
							const treeFiles = json.tree.filter(e => e.type === 'blob' && e.path.startsWith(basePath + '/'));
							return { basePath, files: treeFiles };
						} catch (e) {
							// ignore and try next branch
						}
					}
					return null;
				}

				try {
					const treeResult = await fetchTreeInstead(apiBase);

					const yearsSeen = new Set();

					if (treeResult) {
						const groups = new Map(); // year -> comp -> wu -> [filenames]
						const basePath = treeResult.basePath;
						for (const file of treeResult.files) {
							if (!/\.md$/i.test(file.path)) continue;
							// path parts after basePath: year/comp/wu/file.md
							const rel = file.path.substring(basePath.length + 1).split('/');
							if (rel.length < 4) continue; // not in expected repo layout (ie. non wu, very very WIP wu, etc)
							const [year, comp, wu, ...rest] = rel;
							const fname = rest.join('/');
							groups.set(year, groups.get(year) || new Map());
							const compMap = groups.get(year);
							compMap.set(comp, compMap.get(comp) || new Map());
							const wuMap = compMap.get(comp);
							wuMap.set(wu, (wuMap.get(wu) || []).concat(fname));
						}

						// build DOM from groups
						for (const [year, compMap] of [...groups.entries()].sort((a, b) => b[0].localeCompare(a[0]))) {
							yearsSeen.add(year);
							const { yearLi, yearUl } = getOrCreateYearNode(year);
							for (const [comp, wuMap] of [...compMap.entries()].sort((a, b) => a[0].localeCompare(b[0]))) {
								const { compLi, compUl } = getOrCreateCompNode(yearUl, comp);
								for (const [wu, files] of [...wuMap.entries()].sort((a, b) => a[0].localeCompare(b[0]))) {
									const href = `../${basePath}/${encodeURIComponent(year)}/${encodeURIComponent(comp)}/${encodeURIComponent(wu)}/`;
									appendWuIfNotExists(compUl, href, wu, files);
								}
							}
						}
					} else {
						// fallback if can't fetch everything at once (this would take lots of github api fetches and its way more likely for the user to get rate-limited)
						const dirRes = await fetch(apiBase);
						if (!dirRes.ok) {
							// sth bad happened, usually the user got rate limited
							if (!manualLinks.size) {
								if (dirRes.status === 403) {
									ul.insertAdjacentHTML('beforeend', '<li>Unable to fetch writeups due to github API rate limiting, please try again later.</li>');
								} else {
									ul.insertAdjacentHTML('beforeend', '<li>Unable to fetch writeups, please try again later. If this issue persists, scream at us in discord and we will fix it asap</li>');
								}
							} else {
								if (dirRes.status === 403) {
									ul.insertAdjacentHTML('beforeend', '<li>Unable to fetch newer writeups due to github API rate limiting. Please try again later, and view the statically loaded writeups instead.</li>');
								} else {
									ul.insertAdjacentHTML('beforeend', '<li>Unable to fetch newer writeups, please try again later. If this issue persists, scream at us in discord and we will fix it asap</li>');
								}
							}
							return;
						}
						const years = await dirRes.json();
						years.sort((a, b) => b.name.localeCompare(a.name));

						for (const year of years) {
							if (year.type !== 'dir') continue;
							yearsSeen.add(year.name);
							const { yearLi, yearUl } = getOrCreateYearNode(year.name);

							const compsRes = await fetch(`${apiBase}${year.name}`);
							if (!compsRes.ok) continue;
							const comps = await compsRes.json();
							comps.sort((a, b) => a.name.localeCompare(b.name));

							for (const comp of comps) {
								if (comp.type !== 'dir') continue;
								const { compLi, compUl } = getOrCreateCompNode(yearUl, comp.name);

								const wusRes = await fetch(`${apiBase}${year.name}/${comp.name}`);
								if (!wusRes.ok) continue;
								const wus = await wusRes.json();
								wus.sort((a, b) => a.name.localeCompare(b.name));

								for (const wu of wus) {
									if (wu.type !== 'dir') continue;
									const wuPath = `./${encodeURIComponent(year.name)}/${encodeURIComponent(comp.name)}/${encodeURIComponent(wu.name)}/`;
									appendWuIfNotExists(compUl, `./writeups/${wuPath}`, wu.name);
								}
							}
						}
					}

					Array.from(ul.querySelectorAll('li[data-auto="1"]')).forEach(li => {
						if (li.parentElement === ul) {
							const yearText = li.firstChild?.nodeType === Node.TEXT_NODE ? li.firstChild.textContent.trim() : null;
							if (yearText && !yearsSeen.has(yearText)) li.remove();
						}
					});

				} catch (err) {
					if (!manualLinks.size) {
						ul.insertAdjacentHTML('beforeend', '<li>Error loading writeups. If you didn\'t change anything please scream at us in discord with the console logged error :pray:</li>');
					}
					console.error(err);
				} finally {
					if (loadingNotice && loadingNotice.parentElement) loadingNotice.parentElement.removeChild(loadingNotice);
				}
			}

			document.addEventListener('DOMContentLoaded', loadDirectory);
		</script>

		<main class="main">
			<div class="card">
				<header class="writeups-header">
					<h1>Writeups</h1>
					<div class="writeups-stats">
						<span id="writeup-count">Loading...</span>
						<span id="filter-info"></span>
					</div>
				</header>
				<ul id="writeups-list">
					<!-- populated dynamically unless entries manually added here (idk cuz your wu is special or the auto fetch script is crying for help and can't get your writeup or sth) -->
					<!-- <li>[COATING OR ETC]<ul> -->
					<!-- <li><a href="./writeups/YEAR/COMP/CHAL/">[DISPLAY NAME]</a></li> -->
					<!-- </ul></li> -->
				</ul>
				<!-- <div id="readme" style="margin-top:1em;"></div> -->
			</div>
		</main>
	</div>
</body>

</html>